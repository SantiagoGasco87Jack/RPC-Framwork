// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: src/clientcompat.proto
import { BinaryReader, BinaryWriter } from "google-protobuf";
import {
  JSONrequest,
  PBrequest,
  createMethodHandler,
  ServiceHandler,
} from "twirpscript";

type ByteSource = ArrayBuffer | Uint8Array | number[] | string;

export interface Empty {}

export interface Req {
  v: string;
}

export interface Resp {
  v: number;
}

export interface ClientCompatMessage {
  service_address: string;
  method: ClientCompatMessage.CompatServiceMethod;
  request: Uint8Array;
}

export namespace ClientCompatMessage {
  export enum CompatServiceMethod {
    NOOP = 0,
    METHOD = 1,
  }
}

export namespace Empty {
  export function writeMessage(msg: Empty, writer: BinaryWriter): void {}

  export function encode(empty: Empty): Uint8Array {
    const writer = new BinaryWriter();
    writeMessage(empty, writer);
    return writer.getResultBuffer();
  }

  export function readMessage(msg: Partial<Empty>, reader: BinaryReader): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  }

  export function decode(bytes: ByteSource): Empty {
    const reader = new BinaryReader(bytes);
    const message = {};
    readMessage(message, reader);
    return message as Empty;
  }
}

export namespace Req {
  export function writeMessage(msg: Req, writer: BinaryWriter): void {
    if (msg.v) {
      writer.writeString(1, msg.v);
    }
  }

  export function encode(req: Req): Uint8Array {
    const writer = new BinaryWriter();
    writeMessage(req, writer);
    return writer.getResultBuffer();
  }

  export function readMessage(msg: Partial<Req>, reader: BinaryReader): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.v = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.v) {
      msg.v = "";
    }
  }

  export function decode(bytes: ByteSource): Req {
    const reader = new BinaryReader(bytes);
    const message = {};
    readMessage(message, reader);
    return message as Req;
  }
}

export namespace Resp {
  export function writeMessage(msg: Resp, writer: BinaryWriter): void {
    if (msg.v) {
      writer.writeInt32(1, msg.v);
    }
  }

  export function encode(resp: Resp): Uint8Array {
    const writer = new BinaryWriter();
    writeMessage(resp, writer);
    return writer.getResultBuffer();
  }

  export function readMessage(msg: Partial<Resp>, reader: BinaryReader): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.v = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.v) {
      msg.v = 0;
    }
  }

  export function decode(bytes: ByteSource): Resp {
    const reader = new BinaryReader(bytes);
    const message = {};
    readMessage(message, reader);
    return message as Resp;
  }
}

export namespace ClientCompatMessage {
  export function writeMessage(
    msg: ClientCompatMessage,
    writer: BinaryWriter
  ): void {
    if (msg.service_address) {
      writer.writeString(1, msg.service_address);
    }
    if (msg.method) {
      writer.writeEnum(2, msg.method);
    }
    if (msg.request) {
      writer.writeBytes(3, msg.request);
    }
  }

  export function encode(clientCompatMessage: ClientCompatMessage): Uint8Array {
    const writer = new BinaryWriter();
    writeMessage(clientCompatMessage, writer);
    return writer.getResultBuffer();
  }

  export function readMessage(
    msg: Partial<ClientCompatMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.service_address = reader.readString();
          break;
        }
        case 2: {
          msg.method = reader.readEnum();
          break;
        }
        case 3: {
          msg.request = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.service_address) {
      msg.service_address = "";
    }
    if (!msg.method) {
      msg.method = 0;
    }
    if (!msg.request) {
      msg.request = new Uint8Array();
    }
  }

  export function decode(bytes: ByteSource): ClientCompatMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    readMessage(message, reader);
    return message as ClientCompatMessage;
  }
}

/*
 * CompatService Protobuf Client
 */

export async function Method(url: string, req: Req): Promise<Resp> {
  const response = await PBrequest(
    url + "/twirp/twirp.clientcompat.CompatService/Method",
    Req.encode(req)
  );
  return Resp.decode(response);
}
export async function NoopMethod(url: string, empty: Empty): Promise<Empty> {
  const response = await PBrequest(
    url + "/twirp/twirp.clientcompat.CompatService/NoopMethod",
    Empty.encode(empty)
  );
  return Empty.decode(response);
}

/*
 * CompatService JSON Client
 */

export async function MethodJSON(url: string, req: Req): Promise<Resp> {
  const response = await JSONrequest<Resp>(
    url + "/twirp/twirp.clientcompat.CompatService/Method",
    req
  );
  return response;
}
export async function NoopMethodJSON(
  url: string,
  empty: Empty
): Promise<Empty> {
  const response = await JSONrequest<Empty>(
    url + "/twirp/twirp.clientcompat.CompatService/NoopMethod",
    empty
  );
  return response;
}

/*
 * CompatService Service
 */
export interface CompatService {
  Method: (req: Req) => Promise<Resp> | Resp;
  NoopMethod: (empty: Empty) => Promise<Empty> | Empty;
}

export function CompatServiceHandler(service: CompatService): ServiceHandler {
  return {
    path: "twirp.clientcompat.CompatService",
    methods: {
      Method: createMethodHandler({
        handler: service.Method,
        encode: Resp.encode,
        decode: Resp.decode,
      }),
      NoopMethod: createMethodHandler({
        handler: service.NoopMethod,
        encode: Empty.encode,
        decode: Empty.decode,
      }),
    },
  };
}
